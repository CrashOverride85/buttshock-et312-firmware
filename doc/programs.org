* ET-312 Programs and Modules
** Introduction
This document contains notes about how programs and modules work.  You need to be
familiar with the memory layout and refer to
[[https://github.com/metafetish/buttshock-protocol-docs/blob/master/doc/et312-protocol.org][ET312 Protocol Documentation]].

*** Terminology

- A Program is either an Internal or Use Uploaded program.  Examples of Programs are "Waves", "Phase 2", "User 1".
- Each Program is made up of a number of Modules.
- Each Module contains a variable number of Instructions.
- The Instruction set is very limited, mostly just allowing certain memory operations.

*** Loading a Program (inbuilt Programs)

- As a user you select a program name using the buttons on the box
- This runs "calltable 18" with the Program number
- The firmware will set up some defaults into the memory locations 0x80+ (channel A) and 0x180+ (channel B) that are the same for every Program
- Module 1 is loaded for both channel A and channel B
- The firmware has a code switch statement for the Program to which Module or Modules get loaded
- This runs "calltable 22" for each Module number
- The Instructions from that Module are unpacked and parsed, one by one, by "calltable 30"
- Each Instruction will read or write or manipulate memory (specifically the 0x80+ and 0x180+ locations)
- There is a bit of added complexity due to the ability to "Split" some Programs
- There is a bit of additional hardcoding going on in the firmware to handle the "Random 1" mode and audio modes
- Some other bits of running code check the Program number and do hardcoded tweaks

The Modules do not stay running continuously, they are only used to do an set up of memory locations.  Changes that then
happen (like intensity changes, frequency changes) all take place based on the counters and timers and other memory
settings.

Modules can however set up triggers that can cause Modules to get run at some later point, so for example a Module could set
up one of the timers to run, and when the timer reaches some value it causes a different
Module to then get loaded.  The "Rhythm" mode for example cycles between three different Modules in this way.

You can use the utility "module-decode.py" in this repo to display the Instructions for a given Module, both in-built
using the firmware image, or by examining the memory on a box.  For example:

#+BEGIN_EXAMPLE
$ python3 module-decode.py -i ../firmware/312-16-decrypted.bin -d ../../buttshock-protocol-docs/doc/et312-protocol.org -m 11 
#+END_EXAMPLE

*** Split Programs

Some Programs have the ability to be "Split", where a different Program runs on channel A to channel B.  This causes the Program
loading code to be a little more complex for both cases.  

- TBD

*** Defaults and Module 1

Each time a new Program is started the default values get loaded, for both channel A and B these set:

- Ramp: runs at rate 0x07 with step 0x01 using the 244Hz timer between 0x9c and 0xff, stopping at the end.  This causes the Program to ramp up to full power over 3 seconds ( (0xff-0x9c) * 244/7 )
- Intensity: static with value 0xff.  If changed to use a timer, the defaults set the step to 0x01, rate to 0x01, and range 0xcd to 0xff, reversing at the maximum and minimum.
- Frequency: set to the value of the MA knob.  If changed to use a timer, the default set the step to 0x01, rate to 0x01, and range 0x09 to 0x64 starting from 0x16, reversing at the maximum and minimum.
- Width: set to the advanced paramer default.  If changed to use a timer, the default set the step to 0x01, rate to 0x01, and range 0x32 to 0xc8 starting from 0x82, reversing at the maximum and minimum.

Module 1 is then always loaded for both channel A and B which just turns on the output gates:

#+BEGIN_EXAMPLE
memory[0090 *Channel A: Current Gate Value* (0x06)]=07
memory[0190 *Channel B: Current Gate Value* (0x06)]=07
#+END_EXAMPLE

See also: [[https://github.com/metafetish/buttshock-protocol-docs/blob/master/doc/et312-protocol.org#409c-40bf---main-variables][Main variables]]

*** Program "Waves" is Modules 11, 12

If you select Program "Waves" then the firmware loads Module 11.  Module 11 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0086 *Multi Adjust Range Min* (0x0f)]=01
memory[0087 *Multi Adjust Range Max* (0xff)]=40
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=41
memory[00bb *Channel A: Current Width Modulation Increment* (0x01)]=02
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=41
memory[00b0 *Channel A: Current Frequency Modulation Max* (0x64)]=80
#+END_EXAMPLE

So this:

- Sets the MA knob range from 0x01 to 0x40
- A Intensity: static with value 0xff
- A Frequency: changes in steps of 0x01, rate from MA knob (0x01-0x40), in the range 0x09 to 0x80, using the 244Hz timer, reversing at maximum and maximum.
- A Width: changes in steps of 0x02, rate from MA knob (0x01-0x40), in the range 0x32 to 0xc8, using the 244Hz timer, reversing at minimum and maximum.

If the user is not using the Split mode, the firmware will then also load Module 11 for channel B, then Module 12 which
together form these Instructions:

#+BEGIN_EXAMPLE
memory[01be *Channel B: Current Width Modulation Select* (0x04)]=41
memory[01bb *Channel B: Current Width Modulation Increment* (0x01)]=03
memory[01b5 *Channel B: Current Frequency Modulation Select* (0x08)]=41
memory[01b0 *Channel B: Current Frequency Modulation Max* (0x64)]=40
#+END_EXAMPLE

So this:

- B Intensity: static with value 0xff
- B Frequency: changes in steps of 0x01, rate from MA knob (0x01-0x40), in the range 0x09 to 0x40, using the 244Hz timer, reversing at maximum and maximum.
- B Width: changes in steps of 0x03, rate from MA knob (0x01-0x40), in the range 0x32 to 0xc8, using the 244Hz timer, reversing at minimum and maximum.

*** Program "Stroke" is Modules 3, 4

If you select Program "Stroke" then the firmware loads Module 3.  Module 3 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0086 *Multi Adjust Range Min* (0x0f)]=00
memory[0087 *Multi Adjust Range Max* (0xff)]=20
memory[00a9 *Channel A: Current Intensity Modulation Step* (0x01)]=02
memory[00aa *Channel A: Current Intensity Action at Min* (0xff)]=fe
memory[00ab *Channel A: Current Intensity Action at Max* (0xff)]=fe
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=55
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=00
memory[00b7 *Channel A: Current Width Modulation Value* (0x82)]=ff
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=00
memory[0090 *Channel A: Current Gate Value* (0x06)]=05
#+END_EXAMPLE

So this

- Sets the MA knob range from 0x00 to 0x20
- A Intensity: changes in steps of 0x02 over the range of minimum to 0xff, using the 244Hz timer.  Rate is from the MA knob.  Minimum is set to inverse of the advanced parameter default for Intensity.  When reaching the maximum or minimum the output gate toggles and reverses direction.
- A Frequency: changes in steps of 0x01, rate 0x01 in the range 0x09 to 0x64, (the frequency does not change by the MA knob).
- A Width: changes in steps of 0x01, rate 0x01 in the range 0x32 to 0xc8, reversing at minimum and maximum.  (starting value is 0xff).  (Does not use the advance parameter default).

If the user is not using the Split mode, the firmware will then also load Module 3 for channel B, then Module 4 which
together form these Instructions:

#+BEGIN_EXAMPLE
memory[01a6 *Channel B: Current Intensity Modulation Min* (0xcd)]=e6
memory[01a9 *Channel B: Current Intensity Modulation Step* (0x01)]=01
memory[01aa *Channel B: Current Intensity Action at Min* (0xff)]=fe
memory[01ab *Channel B: Current Intensity Action at Max* (0xff)]=fe
memory[01ac *Channel B: Current Intensity Modulation Select* (0x00)]=41
memory[01b5 *Channel B: Current Frequency Modulation Select* (0x08)]=00
memory[01b7 *Channel B: Current Width Modulation Value* (0x82)]=d8
memory[01be *Channel B: Current Width Modulation Select* (0x04)]=00
memory[0190 *Channel B: Current Gate Value* (0x06)]=05
#+END_EXAMPLE

This sets up:

- B Intensity: changes in steps of 0x01 over the range of 0xe6 to 0xff, using the 244Hz timer.  Rate is from the MA knob.  When reaching the maximum or minimum the output toggles and reverses direction.
- B Frequency: changes in steps of 0x01, rate 0x01 in the range 0x09 to 0x64, (the frequency does not change).
- B Width: changes in steps of 0x01, rate 0x01 in the range 0x32 to 0xc8, reversing at minimum and maximum.  (starting value is 0xd8).  (Does not use the advance parameter default).

*** Program "Climb" is Modules 5-10

If you select Program "Climb" then the firmware loads Module 5.  Module 5 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0086 *Multi Adjust Range Min* (0x0f)]=01
memory[0087 *Multi Adjust Range Max* (0xff)]=64
memory[00ae *Channel A: Current Frequency Modulation Value* (0x16)]=ff
memory[00b0 *Channel A: Current Frequency Modulation Max* (0x64)]=ff
memory[00b2 *Channel A: Current Frequency Modulation Step* (0x01)]=01
memory[00b3 *Channel A: Current Frequency Modulation Action Min* (0xff)]=06
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=41
#+END_EXAMPLE

- Sets the MA range from 0x01-0x64
- A Intensity: static with value 0xff.  
- A Width: set to the advanced paramer default.  
- A Frequency: changes in steps of 0x01, Uses 244Hz timer, rate from the MA knob, in the range 0xff to 0x09 starting at 0xff.  When reaching the minimum will trigger Module 6

Module 6:

#+BEGIN_EXAMPLE
memory[00b2 *Channel A: Current Frequency Modulation Step* (0x01)]=02
memory[00ae *Channel A: Current Frequency Modulation Value* (0x16)]=ff
memory[00b3 *Channel A: Current Frequency Modulation Action Min* (0xff)]=07
#+END_EXAMPLE

- Changes the Frequency step to 0x02, starting at 0xff down to 0x09, when reaches minimum triggers Module 7

Module 7:

#+BEGIN_EXAMPLE
memory[00b2 *Channel A: Current Frequency Modulation Step* (0x01)]=04
memory[00ae *Channel A: Current Frequency Modulation Value* (0x16)]=ff
memory[00b3 *Channel A: Current Frequency Modulation Action Min* (0xff)]=05
#+END_EXAMPLE

- Changes the Frequency step to 0x04, starting at 0xff down to 0x09, when reaches minimum triggers Module 5

If the user is not using the Split mode, the firmware will then also load Module 5 for channel B, then Module 8 which
together form these Instructions:

#+BEGIN_EXAMPLE
memory[01ae *Channel B: Current Frequency Modulation Value* (0x16)]=ff
memory[01b0 *Channel B: Current Frequency Modulation Max* (0x64)]=ff
memory[01b2 *Channel B: Current Frequency Modulation Step* (0x01)]=01
memory[01b3 *Channel B: Current Frequency Modulation Action Min* (0xff)]=09
memory[01b5 *Channel B: Current Frequency Modulation Select* (0x08)]=41
#+END_EXAMPLE

- B Intensity: static with value 0xff.  
- B Width: set to the advanced paramer default.  
- B Frequency: changes in steps of 0x01, Uses 244Hz timer, rate from the MA knob, in the range 0xff to 0x09 starting at 0xff.  When reaching the minimum will trigger Module 9

Module 9:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=02
memory[01b2 *Channel B: Current Frequency Modulation Step* (0x01)]=02
memory[01ae *Channel B: Current Frequency Modulation Value* (0x16)]=ff
memory[01b3 *Channel B: Current Frequency Modulation Action Min* (0xff)]=0a
#+END_EXAMPLE

- B Frequency: changes in steps of 0x02, in the range 0xff to 0x09 starting at 0xff.  When reaching the minimum will trigger Module 10

Module 10:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=02
memory[01b2 *Channel B: Current Frequency Modulation Step* (0x01)]=05
memory[01ae *Channel B: Current Frequency Modulation Value* (0x16)]=ff
memory[01b3 *Channel B: Current Frequency Modulation Action Min* (0xff)]=08
#+END_EXAMPLE

- B Frequency: changes in steps of 0x05, in the range 0xff to 0x09 starting at 0xff.  When reaching the minimum will trigger Module 8

*** Program "Combo" is Modules 13, 33

If you select Program "Combo" then the firmware loads Module 13.  Module 13 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0086 *Multi Adjust Range Min* (0x0f)]=00
memory[0087 *Multi Adjust Range Max* (0xff)]=40
memory[009a *Channel A: Current Gate Select* (0x00)]=4a
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=02
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=26
#+END_EXAMPLE

- TBD

If the user is not using the Split mode, the firmware will then also load Module 13 for channel B, then Module 33 which
together form these Instructions:

#+BEGIN_EXAMPLE
memory[019a *Channel B: Current Gate Select* (0x00)]=4a
memory[01b2 *Channel B: Current Frequency Modulation Step* (0x01)]=02
memory[01b5 *Channel B: Current Frequency Modulation Select* (0x08)]=02
memory[01bb *Channel B: Current Width Modulation Step* (0x01)]=02
memory[01be *Channel B: Current Width Modulation Select* (0x04)]=26
#+END_EXAMPLE

- TBD

*** Program Intense is Modules 14, 2

If you select Program "Intense" then the firmware loads Module 14.  Module 14 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0086 *Multi Adjust Range Min* (0x0f)]=09
#+END_EXAMPLE

- A Intensity: static with value 0xff.  
- A Frequency: set to the value of the MA knob.  Between 0x0f and 0x09
- A Width: set to the advanced parameter default.  

If the user is not using the Split mode, the firmware will then also load Module 14 for channel B, then Module 2 which
together form these Instructions:

#+BEGIN_EXAMPLE
memory[0198 *Channel B: Current Gate OnTime* (0x3e)]=3f
memory[0199 *Channel B: Current Gate OffTime* (0x3e)]=3f
memory[019a *Channel B: Current Gate Select* (0x00)]=01
#+END_EXAMPLE

- B Intensity: static with value 0xff.  
- B Frequency: set to the value of the MA knob.  Between 0x0f and 0x09
- B Width: set to the advanced parameter default.
- B will turn on and off using the 244Hz timer, on for 0x3d and off for 0x3f cycles (giving 2Hz)

*** Program Rhythm is Modules 15, 16, 17

If you select Program "Rhythm" then the firmware loads Module 15.  Module 15 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0086 *Multi Adjust Range Min* (0x0f)]=01
memory[0087 *Multi Adjust Range Max* (0xff)]=17
memory[0095 *Next module timer max* (0xff)]=1f
memory[0095 *Next module timer max* (0xff)]=1f
memory[0096 *Next module flag* (0x00)]=02
memory[0097 *Next module number* (0x00)]=10
memory[009a *Channel A: Current Gate Select* (0x00)]=49
memory[00a5 *Channel A: Current Intensity Modulation Value* (0xff)]=e0
memory[00a6 *Channel A: Current Intensity Modulation Min* (0xcd)]=e0
memory[00a9 *Channel A: Current Intensity Modulation Step* (0x01)]=00
memory[00ab *Channel A: Current Intensity Action at Max* (0xff)]=fd
memory[00ab *Channel A: Current Intensity Action at Max* (0xff)]=fd
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=01
memory[00b7 *Channel A: Current Width Modulation Value* (0x82)]=46
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=00
#+END_EXAMPLE

- Sets a timer using the 30.5Hz clock.  Once it counts up to 0x1f (one second) then Module 16 will be loaded
- TBD

Module 15 triggers Module 16:

#+BEGIN_EXAMPLE
memory[0097 *Next module number* (0x00)]=11
memory[00a5 *Channel A: Current Intensity Modulation Value* (0xff)]^01
memory[00a5 *Channel A: Current Intensity Modulation Value* (0xff)]+=01
memory[00b7 *Channel A: Current Width Modulation Value* (0x82)]=b4
#+END_EXAMPLE

- Timer restarts.  Once it counts up to 0x1f (one second) then Module 17 will be loaded
- TBD

Module 16 triggers Module 17:

#+BEGIN_EXAMPLE
memory[0097 *Next module number* (0x00)]=10
memory[00b7 *Channel A: Current Width Modulation Value* (0x82)]=46
#+END_EXAMPLE

- Timer restarts.  Once it counts up to 0x1f (one second) then Module 16 will be loaded
- TBD

*** Program "Audio 1" is Module 23

If you select Program "Audio 1" then the firmware loads Module 23.  It also sets up a flag for other
code that we're in a mono audio mode, and has hardcoded settings for the gate outputs (memory 0x90 and 0x190).

Module 23 contains these Instructions:

#+BEGIN_EXAMPLE
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=04
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=00
#+END_EXAMPLE

- Intensity: static with value 0xff
- Frequency: set to the value of the advanced default
- Width: static with the value 0x82

*** Program "Audio 2" is Module 23

If you select Program "Audio 2" then the firmware also loads Module 23.  Everything is the same as above for
"Audio 1" except the flag for mono isn't set.

*** Program "Audio 3" is Module 34

If you select Program "Audio 3" then the firmware loads Module 34.  It also has hardcoded settings for the
gate outputs (memory 0x90 and 0x190) and output control flags 0x83.

Module 34 contains these Instructions:

#+BEGIN_EXAMPLE
memory[00ae *Channel A: Current Frequency Modulation Value* (0x16)]=0a
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=00
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=00
#+END_EXAMPLE

- Intensity: static with value 0xff
- Frequency: static with value 0x0a
- Width: static with the value 0x82

*** Program "Random 2" is Module 32

If you select Program "Random 2" then the firmware loads Module 32.  Module 32 contains these Instructions:

#+BEGIN_EXAMPLE
memory[008d Random Number Min]=01
memory[008e Random Number Max]=04
memory[01b2 *Channel B: Current Frequency Modulation Step* (0x01)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[00a8 *Channel A: Current Intensity Modulation Rate* (0x01)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[01a8 *Channel B: Current Intensity Modulation Rate* (0x01)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[00b1 *Channel A: Current Frequency Modulation Rate* (0x01)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[01b1 *Channel B: Current Frequency Modulation Rate* (0x01)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[00ba *Channel A: Current Width Modulation Rate* (0x01)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[01ba *Channel B: Current Width Modulation Rate* (0x01)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=01
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=02
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=02
memory[0196 *Next module flag* (0x00)]=03
memory[0197 *Next module number* (0x00)]=20
memory[008d Random Number Min]=05
memory[008e Random Number Max]=1f
memory[0195 *Next module timer max* (0xff)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
#+END_EXAMPLE

- A Intensity: Using 30.5Hz timer, step to random between 1-4, rate to random between 1-4, and range 0xcd to 0xff, reversing at the maximum and minimum.
- B Intensity: Using 30.5Hz timer, step to random between 1-4, rate to random between 1-4, and range 0xcd to 0xff, reversing at the maximum and minimum.
- A Frequency: Using 30.5Hz timer, step to random between 1-4, rate to random between 1-4, and range 0x09 to 0x64 starting from 0x16, reversing at the maximum and minimum.
- B Frequency: Using 30.5Hz timer, step to random between 1-4, rate to random between 1-4, and range 0x09 to 0x64 starting from 0x16, reversing at the maximum and minimum.
- A Width: Using 244Hz timer, step to 0x01, rate to random between 1-4, and range 0x32 to 0xc8 starting from 0x82, reversing at the maximum and minimum.
- B Width: Using 244Hz timer, step to 0x01, rate to random between 1-4, and range 0x32 to 0xc8 starting from 0x82, reversing at the maximum and minimum.
- After a random time using .953Hz timer between 0x05-0x1f (5-32 seconds), reload Module 32

*** Program "Toggle" is Modules 18, 19

If you select Program "Toggle" then the firmware loads Module 18.  Module 18 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0086 *Multi Adjust Range Min* (0x0f)]=00
memory[0087 *Multi Adjust Range Max* (0xff)]=7f
memory[0096 *Next module flag* (0x00)]=02
memory[008c Module temporary byte store]=memory[020d *Current Multi Adjust Value / COMM_MULTI_AVG*]
memory[0095 *Next module timer max* (0xff)]=memory[008c Module temporary byte store]
memory[0097 *Next module number* (0x00)]=13
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=04
memory[00bf *Channel A: Current Width Modulation Timer* (0x00)]=04
memory[0090 *Channel A: Current Gate Value* (0x06)]=07
memory[0190 *Channel B: Current Gate Value* (0 when no output)]=06
#+END_EXAMPLE

The above runs for both Channel A then with memory modified for Channel B and causes:

- A/B Intensity: static with value 0xff. 
- A/B Frequency: static at the advanced parameter default
- A/B Width: set to the advanced parameter default
- Channel A gate is turned on, Channel B gate is turned off
- MA range is 0x00-0x7f
- Sets the "Next Module timer" maximum to the value of the MA knob and to trigger Module 19, flag of 2 means use the 30.5Hz timer (since
the maximum count is 0x7f this gives effective toggle time of between 0 and about 4 seconds)

Module 18 triggers Module 19:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=01
memory[0090 *Channel A: Current Gate Value* (0x06)]=06
memory[0085 when module loading determines which channels to set (0x03)]=03
memory[0097 *Next module number* (0x00)]=12
memory[0190 *Channel B: Current Gate Value* (0 when no output)]=07
memory[008c Module temporary byte store]=memory[020d *Current Multi Adjust Value / COMM_MULTI_AVG*]
memory[0095 *Next module timer max* (0xff)]=memory[008c Module temporary byte store]
#+END_EXAMPLE

- Channel A gate is turned off, Channel B gate is turned on
- Sets the "Next Module timer" maximum to the value of the MA knob and to trigger Module 18

*** Program Orgasm is Modules 24, 25, 26, 27

If you select Program "Toggle" then the firmware loads Module 24.  Module 24 contains these Instructions:

#+BEGIN_EXAMPLE
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=00
memory[00b7 *Channel A: Current Width Modulation Value* (0x82)]=32
memory[00bb *Channel A: Current Width Modulation Step* (0x01)]=04
memory[00ba *Channel A: Current Width Modulation Rate* (0x01)]=01
memory[00b8 *Channel A: Current Width Modulation Min* (0x32)]=32
memory[0085 when module loading determines which channels to set (0x03)]=01
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=01
memory[00bd *Channel A: Current Width Modulation Action Max* (0xff)]=19
memory[01be *Channel B: Current Width Modulation Select* (0x04)]=00
#+END_EXAMPLE

- TBD

Module 24 triggers Module 25:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=01
memory[00bb *Channel A: Current Width Modulation Step* (0x01)]=ff
memory[00bc *Channel A: Current Width Modulation Action Min* (0xff)]=1a
memory[01be *Channel B: Current Width Modulation Select* (0x04)]=01
memory[01bd *Channel B: Current Width Modulation Action Max* (0xff)]=ff
memory[0085 when module loading determines which channels to set (0x03)]=03
memory[00b8 *Channel A: Current Width Modulation Min* (0x32)]+=02
memory[00b8 *Channel A: Current Width Modulation Min* (0x32)]^02
#+END_EXAMPLE

- TBD

Module 25 triggers Module 26:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=01
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=00
memory[01bc *Channel B: Current Width Modulation Action Min* (0xff)]=1b
#+END_EXAMPLE

- TBD

Module 26 triggers Module 27:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=01
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=01
memory[01be *Channel B: Current Width Modulation Select* (0x04)]=00
memory[00bb *Channel A: Current Width Modulation Step* (0x01)]=01
memory[01bb *Channel B: Current Width Modulation Step* (0x01)]=01
#+END_EXAMPLE

- TBD

*** Program "Torment" is Modules 28, 29, 30, 31

If you select Program "Torment" then the firmware loads Module 28.  Module 28 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=03
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=00
memory[00a5 *Channel A: Current Intensity Modulation Value* (0xff)]=b0
memory[0090 *Channel A: Current Gate Value* (0x06)]=06
memory[008d Random Number Min]=05
memory[008e Random Number Max]=18
memory[0195 *Next module timer max* (0xff)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[0196 *Next module flag* (0x00)]=03
memory[00ab *Channel A: Current Intensity Action at Max* (0xff)]=1c
memory[008d Random Number Min]=e0
memory[008e Random Number Max]=ff
memory[00a7 *Channel A: Current Intensity Modulation Max* (0xff)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[008d Random Number Min]=06
memory[008e Random Number Max]=3f
memory[00a8 *Channel A: Current Intensity Modulation Rate* (0x01)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[008d Random Number Min]=1d
memory[008e Random Number Max]=1f
memory[0197 *Next module number* (0x00)]=rand(memory[008d Random Number Min],memory[008e Random Number Max])
memory[00ab *Channel A: Current Intensity Action at Max* (0xff)]=ff
#+END_EXAMPLE

- TBD

Module 29 contains:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=03
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=01
memory[0090 *Channel A: Current Gate Value* (0x06)]=07
memory[00ab *Channel A: Current Intensity Action at Max* (0xff)]=1c
#+END_EXAMPLE

- TBD

Module 30 contains:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=02
memory[01ac *Channel B: Current Intensity Modulation Select* (0x00)]=01
memory[0190 *Channel B: Current Gate Value* (0 when no output)]=07
memory[01ab *Channel B: Current Intensity Action at Max* (0xff)]=1c
#+END_EXAMPLE

- TBD

Module 31 contains:

#+BEGIN_EXAMPLE
memory[0085 when module loading determines which channels to set (0x03)]=01
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=01
memory[0090 *Channel A: Current Gate Value* (0x06)]=07
memory[00ab *Channel A: Current Intensity Action at Max* (0xff)]=1c
#+END_EXAMPLE

- TBD

*** Program "Phase 1" is Modules 20 and 21

If you select Program "Phase 1" then the firmware loads Module 20.  It also hardcodes the output control
flags at 0x83.  For Channel B it loads Module 20 and then Module 21

Module 20 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0086 *Multi Adjust Range Min* (0x0f)]=01
memory[0087 *Multi Adjust Range Max* (0xff)]=20
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=04
memory[00be *Channel A: Current Width Modulation Select* (0x04)]=00
memory[00b7 *Channel A: Current Width Modulation Value* (0x82)]=7d
#+END_EXAMPLE

- TBD

Module 21 contains these Instructions:

#+BEGIN_EXAMPLE
memory[00b7 *Channel A: Current Width Modulation Value* (0x82)]=79
#+END_EXAMPLE

- TBD

*** Program "Phase 2" is Modules 20 and 21 and 35

If you select Program "Phase 1" then the firmware loads Module 20 then 35.  It also hardcodes the output control
flags at 0x83.  For Channel B it loads Module 20 then 21 then 35. 

Module 35 contains these Instructions:

#+BEGIN_EXAMPLE
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=25
#+END_EXAMPLE

- TBD

*** Program "Phase 3" is Module 22

If you select Program "Phase 3" then the firmware loads Module 22.  Module 22 contains these Instructions:

#+BEGIN_EXAMPLE
memory[0083 *Output Control Flags - COMM_CONTROL_FLAG* (0x00)]=08
memory[0190 *Channel B: Current Gate Value* (0 when no output)]=a0
memory[00ac *Channel A: Current Intensity Modulation Select* (0x00)]=01
memory[0086 *Multi Adjust Range Min* (0x0f)]=cd
memory[0087 *Multi Adjust Range Max* (0xff)]=d4
memory[00b5 *Channel A: Current Frequency Modulation Select* (0x08)]=04
memory[01ac *Channel B: Current Intensity Modulation Select* (0x00)]=09
#+END_EXAMPLE

- TBD

*** Program "Random 1"

This is a special case.

- TBD

** Program to Module list

| Program | Modules used                    |
|---------------+---------------------------------|
| waves  | 11 (A, B), 12 (B) |
| stroke |  3 (A, B),  4 (B) |
| climb  |  5 (A, B), 6 (A, B), 7 (A, B), 8 (B), 9 (B), 10 (B) |
| combo  | 13 (A, B), 33 (B) |
| intense| 14 (A, B),  2 (B) |
| rhythm | 15 (triggers run 16, 17) |
| audio  | 23 |
| audio3 | 34 |
| random2| 32 (triggers load 32 again) |
| toggle | 18 (triggers run 19) |
| orgasm | 24 (triggers run 25, 26, 27) |
| torment| 28-31 |
| phase1 | 20 (A, B), 21 (B) |
| phase2 | 20 (A, B), 21 (B), 35 (A,B) |
| phase3 | 22 (A, B)|
| random1| special hardcoded |

